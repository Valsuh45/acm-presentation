<!doctype html>
<html lang="en">
<head>
    <meta charset="UTF-8"/>
    <link rel="icon" type="image/svg+xml" href="/vite.svg"/>
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <title>Code as a Graph - Neo4j Presentation</title>
</head>
<body>
<div class="reveal">
    <img src="src/assets/logos/favicon-light@.svg" alt="@-logo" class="logo">
    <div class="slides">
        <!-- Title Slide -->
        <section>
            <img src="src/assets/logos/adorsys.png" alt="adorsys-logo">
            <h2>Code as a Graph: Visualizing Software with Neo4j</h2>
            <p>Exploring how graph databases can revolutionize code analysis and visualization</p>
            <p><small>Powered by Neo4j Graph Database Technology</small></p><br>
            <p><small>Presented by <b>Valantine Suh</b><br>
                Associate Full Stack Engineer at adorsys</small></p>
        </section>

        <!-- Introduction -->
        <section>
            <section>
                <h2>Introduction</h2>
                <p>Traditional approaches to code analysis are limited by linear thinking</p>
                <p>Graph databases provide a new way to visualize and query code relationships, so today, we'll explore how Neo4j can transform code into a graph</p>
            </section>
            <section>
                <h3>Agenda</h3>
                <ul>
                    <li>Why Graph Databases for Code?</li>
                    <li>What are Graph Databases?</li>
                    <li>What is Neo4j?</li>
                    <li>Our Use Case: Indexing Code Repositories</li>
                    <li>Demo: Visualizing Code as a Graph</li>
                    <li>Benefits & Challenges</li>
                    <li>Conclusion</li>
                    <li>Q&A</li>
                </ul>
            </section>
        </section>
        <section>
            <h2>Visualizing Code as a Graph</h2>
            <p>Software systems are inherently interconnected - like graphs!</p>
            <div class="mermaid">
                graph TD;
                A[Traditional Analysis] ---> B[Limited Views]
                C[Graph-Based Analysis] ---> D[Rich Relationships]
                    C ---> E[Pattern Discovery]
                    C ---> F[Impact Analysis]
                </div>
            </section>
            <section>
                <h3>Why Graph Databases for Code?</h3>
                <ul>
                    <li>Code has natural relationships: imports, dependencies, inheritance</li>
                    <li>Traditional databases struggle with complex interconnections</li>
                    <li>Graph databases excel at traversing relationships</li>
                    <li>Enable powerful queries across the entire codebase</li>
                </ul>
            </section>
        </section>

        <!-- What are Graph Databases -->
        <section>
            <section>
                <h2>What are Graph Databases?</h2>
                <p>These are databases that use graph structures with nodes, edges, and properties to represent and store data.</p>
                <br>
                <div class="mermaid">
                    graph LR;
                    A[Node: Class] -->|EXTENDS| B[Node: Parent Class]
                    A -->|IMPLEMENTS| C[Node: Interface]
                    A -->|USES| D[Node: Library]
                    B -->|CONTAINS| E[Node: Method]
                </div>
            </section>
            <section>
                <h3>Core Components</h3>
                <ul>
                    <li><strong>Nodes:</strong> Entities (Classes, Methods, Files)</li>
                    <li><strong>Relationships:</strong> Connections between entities</li>
                    <li><strong>Properties:</strong> Key-value pairs storing data</li>
                    <li><strong>Labels:</strong> Categorizing nodes by type</li>
                </ul>
            </section>
            <section>
                <h3>Graph vs Relational</h3>
                <div class="mermaid">
                    graph TD;
                    subgraph "Relational Database"
                    T1[Table: Classes]
                    T2[Table: Methods]
                    T3[Table: Dependencies]
                    T1 -.-> T2
                    T2 -.-> T3
                    end
                    
                    subgraph "Graph Database"
                    N1[Class Node] -->|HAS_METHOD| N2[Method Node]
                    N1 -->|DEPENDS_ON| N3[Library Node]
                    N2 -->|CALLS| N4[Method Node]
                    end
                </div>
            </section>
        </section>

        <!-- Neo4j Database -->
        <section>
            <section>
                <h2>What is Neo4j?</h2>
                <img src="src/assets/images/neo4j-logo.png" alt="Neo4j"><br>
                <p>
                    Neo4j is a native graphical database, which implements a true graph model all the way down to the
                    core level, instead of using a graph abstraction on top of another technology.
                </p>
            </section>
            <section>
                <h3>Key Characteristics</h3>
                <ul>
                    <li>Native graph storage and processing</li>
                    <li>ACID (Atomicity, Consistency, Isolation, Durability) compliant</li>
                    <li>Cypher query language</li>
                    <li>Highly scalable and performant</li>
                </ul>
            </section>
            <section>
                <h3>Cypher Query Language</h3>
                <p>SQL-like syntax for graph queries</p>
                <pre><code>
MATCH (class:Class)-[:HAS_METHOD]->(method:Method)
WHERE class.name = "UserService"
RETURN method.name, method.complexity
                </code></pre>
                <p>Human-readable pattern matching</p>
            </section>
            <section>
                <h3>Performance Benefits</h3>
                <ul>
                    <li><strong>Index-free adjacency:</strong> Relationships are stored as pointers</li>
                    <li><strong>Pattern matching:</strong> Optimized for complex queries</li>
                    <li><strong>Memory efficiency:</strong> Only loads relevant subgraphs</li>
                </ul>
            </section>
        </section>

        <!-- Use Case: GitHub Repo Indexing -->
        <section>
            <section>
                <h2>Our Use Case</h2>
                <h4>"Indexing Code Repositories into Neo4j"</h4><br>
                <p>Transform code repositories into queryable graph structures</p>
            </section>
            <section>
                <h3>What We Index</h3>
                <div class="mermaid">
                    graph TD;
                    A[Code] --> B[Files]
                    A --> C[Directories]
                    B --> D[Classes]
                    B --> E[Functions/Methods]
                    B --> F[Variables]
                    D --> G[Dependencies]
                    E --> H[Function Calls]
                    D --> I[Inheritance]
                </div>
            </section>
            <section>
                <h3>Relationship Types</h3>
                <ul>
                    <li><strong>CONTAINS:</strong> Directory contains files</li>
                    <li><strong>DEFINES:</strong> File defines classes/functions</li>
                    <li><strong>EXTENDS:</strong> Class inheritance</li>
                    <li><strong>IMPLEMENTS:</strong> Interface implementation</li>
                    <li><strong>CALLS:</strong> Function/method invocations</li>
                    <li><strong>IMPORTS:</strong> Module dependencies</li>
                    <li><strong>USES:</strong> Variable/resource usage</li>
                </ul>
            </section>
            <section>
                <h3>Sample Queries</h3>
                <h6><small> Find all classes that depend on a specific library: </small></h6>
                <pre><code>
MATCH (lib:Library {name: "express"})&lt;-[:IMPORTS]-(file:File)-[:DEFINES]-&gt;(class:Class)
RETURN class.name, file.path
                </code></pre><br>


                <h6><small>Detect circular dependencies:</small></h6>
                <pre><code>
            MATCH path = (a:Class)-[:DEPENDS_ON*]->(a)
            WHERE length(path) > 1
            RETURN path
                </code></pre>
            </section>
        </section>

        <!-- Demo Section -->
        <section>
            <section>
                <h2>Demo Time!</h2>
            </section>
            <section>
                <h3>Demo Highlights</h3>
                <ul>
                    <li>Import a sample code</li>
                    <li>Visualize the code structure as a graph</li>
                    <li>Run complex queries to analyze dependencies</li>
                    <li>Identify potential refactoring opportunities</li>
                    <li>Show impact analysis for proposed changes</li>
                </ul>
            </section>
            <section>
                <h3>What You'll See</h3>
                <div class="mermaid">
                    graph LR;
                    A[Code Files] ---> B[Parsed AST]
                    B ---> C[Graph Nodes & Relations]
                    C ---> D[Neo4j Browser]
                    D ---> E[Visual Graph]
                    D ---> F[Query Results]
                </div>
            </section>
        </section>

        <!-- Benefits & Challenges -->
        <section>
            <section>
                <h2>Benefits & Use Cases</h2>
                <ul>
                    <li><strong>Code Reviews:</strong> Better understanding of change impact</li>
                    <li><strong>Refactoring:</strong> Safe restructuring with dependency awareness</li>
                    <li><strong>Onboarding:</strong> Help new developers understand codebase</li>
                    <li><strong>Technical Debt:</strong> Identify problematic areas</li>
                </ul>
            </section>
            <section>
                <h3>Challenges & Considerations</h3>
                <ul>
                    <li><strong>Parsing Complexity:</strong> Different languages, different structures</li>
                    <li><strong>Scale:</strong> Large code bases require optimization</li>
                    <li><strong>Maintenance:</strong> Keeping graph synchronized with code changes</li>
                    <li><strong>Infrastructure:</strong> Neo4j deployment and management</li>
                </ul>
            </section>
        </section>

        <!-- Q&A -->
        <section>
            <section>
                <h2>Questions & Answers</h2>
                <p>Let's discuss your thoughts and explore possibilities!</p>
            </section>
            <section>
                <h3>Common Questions</h3>
                <ul>
                    <li>How does this compare to static analysis tools?</li>
                    <li>What's the performance impact on large codebases?</li>
                    <li>Can this integrate with existing CI/CD pipelines?</li>
                    <li>What programming languages are supported?</li>
                    <li>How do we handle dynamically typed languages?</li>
                </ul>
            </section>
        </section>

        <!-- Conclusion -->
        <section>
            <section data-auto-animate>
                <h2>Conclusion</h2>
                <p>Graph databases open new possibilities for code analysis and visualization</p>
                   Neo4j provides powerful tools for understanding software architecture leading to ease
                   of implementation and maintenance.</p>
            </section>
            <section data-auto-animate>
                <h2>Useful Links</h2>
                <p>
                Graph databases open new possibilities for code analysis, below are the links to relevant resources and repositories
                </p>
                <ul>
                    <li><a href="https://github.com/vymalo/code-graph">Tailored Code Graph Repo</a></li>
                    <li><a href="https://www.npmjs.com/package/@vymalo/code-graph-analyzer">NPM Code Graph Analyzer Package</a></li>
                    <li><a href="https://github.com/ChrisRoyse/CodeGraph">CodeGraph Repo</a></li>
                    <li><a href="https://github.com/Valsuh45/codegraph-cli-agent">Code Graph CLI Agent</a></li>
                    <li><a href="https://neo4j.com/docs/">Neo4j Documentation</a></li>
                    <li><a href="https://neo4j.com/developer/">Neo4j Developer Resources</a></li>
                    <li><a href="https://github.com/Valsuh45/acm-presentation">Presentation Slides</a></li>
                </ul>
            </section>
            <section data-auto-animate>
                <h3>Thank you!</h3>
                <aside class="notes">
                    <p>Neo4j makes complex code relationships simple to understand and query</p>
                </aside>
                <p> Remember: Software is a graph - let's treat it as one! <br>
                    Ready to start visualizing your code as a graph?
                </p>
                <p><small><b><u>Contact: info.cm@adorsys.com</u></b></small></p>
            </section>
        </section>
    </div>
</div>

<script type="module" src="/src/main.ts"></script>
</body>
</html>
